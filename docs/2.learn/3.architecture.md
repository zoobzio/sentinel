---
title: Architecture
description: Internal design and component interactions in sentinel
author: zoobzio
published: 2025-12-30
updated: 2026-01-03
tags:
  - Architecture
  - Internals
  - Design
---

# Architecture

How sentinel's components work together to extract, cache, and query struct metadata.

## Component Overview

```
┌─────────────────────────────────────────────────────────────┐
│                        Public API                           │
│  Inspect[T]()  Scan[T]()  Browse()  Lookup()  Schema()     │
└─────────────────────────────────┬───────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────┐
│                    Sentinel Instance                        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │    Cache    │  │ Tag Registry│  │   Module Path       │ │
│  │ (Permanent) │  │  (RWMutex)  │  │ (debug.BuildInfo)   │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
└─────────────────────────────────┬───────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────┐
│                    Extraction Pipeline                      │
│  ┌──────────────────┐    ┌──────────────────────────────┐  │
│  │ extractMetadata  │───▶│ extractMetadataInternal      │  │
│  │ (single type)    │    │ (with cycle detection)       │  │
│  └──────────────────┘    └───────────────┬──────────────┘  │
│                                          │                  │
│  ┌──────────────────┐    ┌───────────────▼──────────────┐  │
│  │extractFieldMeta  │◀───│  extractRelationships        │  │
│  │ (tags, types)    │    │  (recursive if Scan mode)    │  │
│  └──────────────────┘    └──────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

## Global Singleton

Sentinel uses a global singleton initialised at package load:

```go
var instance *Sentinel

func init() {
    instance = &Sentinel{
        cache:          NewPermanentCache(),
        registeredTags: make(map[string]bool),
        modulePath:     detectModulePath(),
    }
}
```

**Why global state?**

Go's type system is fixed at compile time. A struct's fields, types, and tags cannot change while the program runs. This makes global state appropriate:

- One type system = one metadata cache
- No cache invalidation needed
- No lifecycle management required
- Safe concurrent access after initial extraction

**Why package-level functions?**

Go does not permit methods with type parameters. Functions like `Inspect[T]()` must be package-level—instance-based generic APIs are not possible.

## Cache Architecture

The cache stores metadata keyed by fully qualified domain name (FQDN):

```
github.com/user/project/domain.User
```

### PermanentCache

Sentinel uses `PermanentCache` because types are immutable at runtime:

```go
type PermanentCache struct {
    data map[string]Metadata
    mu   sync.RWMutex
}
```

Operations:
- **Get**: Read lock, map lookup
- **Set**: Write lock, map write
- **Keys**: Read lock, key slice copy

All operations are thread-safe. The cache never expires or invalidates entries.

### Thread Safety Model

| Operation | Lock Type | Contention |
|-----------|-----------|------------|
| Cache read | `RLock` | Low (concurrent reads) |
| Cache write | `Lock` | Momentary (first access only) |
| Tag registry read | `RLock` | Low |
| Tag registry write | `Lock` | Rare (registration only) |

After initial extraction, all operations are read-only and highly concurrent.

## Extraction Pipeline

### Inspect Flow

`Inspect[T]()` extracts metadata for a single type:

```
Inspect[T]()
    │
    ├─▶ Check cache ─── hit ──▶ Return cached
    │
    └─▶ miss
         │
         ▼
    extractMetadata(t)
         │
         ├─▶ extractFieldMetadata(t) ─── fields + tags
         │
         └─▶ extractRelationships(t, nil) ─── relationships only
                                              (no recursion)
         │
         ▼
    Cache and return
```

Key point: `Inspect` passes `nil` for the visited map, so relationship extraction does not recurse.

### Scan Flow

`Scan[T]()` recursively extracts metadata for a type and all related types:

```
Scan[T]()
    │
    ▼
Create visited = map[string]bool{}
    │
    ▼
extractMetadataInternal(t, visited)
    │
    ├─▶ Check visited ─── yes ──▶ Return (cycle prevention)
    │
    └─▶ Mark visited[fqdn] = true
         │
         ├─▶ Check cache ─── hit ──▶ Still scan relationships
         │                           (to discover new types)
         │
         └─▶ miss
              │
              ▼
         extractFieldMetadata(t)
              │
              ▼
         extractRelationships(t, visited)
              │
              └─▶ For each relationship in module domain:
                   │
                   └─▶ extractMetadataInternal(relatedType, visited)
                        (recursive)
              │
              ▼
         Cache and return
```

The `visited` map serves two purposes:
1. **Cycle detection**: Prevents infinite loops from circular references
2. **Mode signal**: Non-nil indicates "Scan mode" for recursive extraction

### Cycle Detection

Circular references are handled by the visited map:

```go
type A struct {
    B *B
}

type B struct {
    A *A  // circular reference
}
```

When scanning `A`:
1. Mark `A` as visited
2. Extract `A.B` relationship, recurse to `B`
3. Mark `B` as visited
4. Extract `B.A` relationship, but `A` is already visited
5. Return cached `A` metadata (no infinite loop)

## Module Boundary Detection

Scan mode only recurses into types within the same module. This prevents extracting metadata for external dependencies.

### Detection Mechanism

At initialisation, sentinel reads the module path from build info:

```go
func detectModulePath() string {
    info, ok := debug.ReadBuildInfo()
    if !ok {
        return ""
    }
    return info.Main.Path  // e.g., "github.com/user/project"
}
```

### Boundary Check

When extracting relationships, sentinel checks if the related type's package belongs to the module:

```go
func (s *Sentinel) isInModuleDomain(targetPkg string) bool {
    return strings.HasPrefix(targetPkg, s.modulePath)
}
```

Example for module `github.com/user/project`:

| Package | In Module? |
|---------|------------|
| `github.com/user/project/domain` | Yes |
| `github.com/user/project/internal/repo` | Yes |
| `github.com/other/library` | No |
| `time` | No |

If build info is unavailable (e.g., `go run` without module), sentinel gracefully degrades to no recursive scanning.

## Relationship Extraction

Relationships are extracted based on field types:

| Field Pattern | Kind | Example |
|---------------|------|---------|
| `T` (struct) | `embedding` (if anonymous) | `User` embedded |
| `T` (struct) | `reference` | `Profile Profile` |
| `*T` | `reference` | `Profile *Profile` |
| `[]T` or `[]*T` | `collection` | `Orders []Order` |
| `map[K]T` or `map[K]*T` | `map` | `Tags map[string]Tag` |

Only relationships to structs within the same package domain are recorded. Primitive types (`[]string`, `map[string]int`) do not create relationships.

## Tag Extraction

Field tags are extracted in two stages:

### Built-in Tags

Always extracted:
- `json`, `validate`, `db`
- `scope`, `encrypt`, `redact`
- `desc`, `example`

### Registered Tags

Custom tags registered via `Tag()`:

```go
sentinel.Tag("gorm")
sentinel.Tag("bson")
```

The tag registry is protected by `sync.RWMutex` for concurrent access.

## Query Operations

### Browse

Returns all cached type FQDNs:

```go
func Browse() []string {
    return instance.cache.Keys()
}
```

### Lookup

Retrieves metadata by FQDN:

```go
func Lookup(typeName string) (Metadata, bool) {
    return instance.cache.Get(typeName)
}
```

### Schema

Exports the entire cache:

```go
func Schema() map[string]Metadata
```

### GetReferencedBy

Performs a reverse lookup—finds all types that reference a given type:

```go
func GetReferencedBy[T any]() []TypeRelationship
```

This iterates through all cached metadata, checking each type's relationships. Performance scales with cache size, but is typically fast due to small type graphs.

## Performance Characteristics

| Operation | First Call | Subsequent Calls |
|-----------|------------|------------------|
| `Inspect[T]()` | Reflection + cache write | Cache read only |
| `Scan[T]()` | Reflection + recursive scan | Cache read only |
| `Browse()` | N/A | O(n) key copy |
| `Lookup()` | N/A | O(1) map access |
| `Schema()` | N/A | O(n) map copy |

After initial extraction, all operations are effectively free (cache hits with read locks).

## Design Decisions

### Why Permanent Cache?

Types cannot change at runtime. Unlike configuration or data that might be reloaded, struct definitions are compiled into the binary. Expiration or invalidation would add complexity with no benefit.

### Why FQDN Keys?

Type names alone are not unique across packages. FQDNs (`package.Type`) guarantee uniqueness and enable unambiguous lookups.

### Why Module-Aware Scanning?

Without boundaries, `Scan` would extract metadata for every struct reachable through the type graph—including standard library and third-party types. Module boundaries keep the focus on application types.

### Why Global State?

Alternatives considered:
- **Per-instance cache**: Requires passing instances everywhere, no clear benefit since type system is shared
- **Dependency injection**: Adds complexity for testing, but `Reset()` already provides test isolation

The global singleton matches Go's type system model: one program, one type system, one cache.

## Next Steps

- [Scanning Guide](../3.guides/1.scanning.md) — practical Inspect vs Scan usage
- [Testing Guide](../3.guides/3.testing.md) — testing patterns with sentinel
- [ERD Diagrams](../4.cookbook/1.erd-diagrams.md) — visualising type graphs
